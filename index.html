<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Professional Headshot Generator</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f5f5f5;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100vh;
      }
      .app-container {
        max-width: 800px;
        width: 100%;
        padding: 20px;
        box-sizing: border-box;
      }
      h1 {
        color: #333;
        text-align: center;
      }
      .controls {
        display: flex;
        justify-content: center;
        margin: 20px 0;
        flex-wrap: wrap;
        gap: 10px;
      }
      button {
        background-color: #4caf50;
        border: none;
        color: white;
        padding: 10px 20px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
        border-radius: 4px;
      }
      button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
      .canvas-container {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 20px;
        margin-top: 20px;
      }
      .canvas-wrapper {
        position: relative;
        width: 320px;
        border: 1px solid #ddd;
        background-color: white;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        border-radius: 4px;
        overflow: hidden;
      }
      .canvas-wrapper h3 {
        text-align: center;
        margin: 10px 0;
        color: #555;
      }
      canvas,
      video {
        display: block;
        width: 100%;
        height: auto;
      }
      #loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        font-size: 24px;
        z-index: 1000;
      }
      .spinner {
        border: 5px solid #f3f3f3;
        border-top: 5px solid #4caf50;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 2s linear infinite;
        margin-bottom: 20px;
      }
      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }
      .hidden {
        display: none !important;
      }
      #status {
        margin-top: 20px;
        text-align: center;
        color: #555;
      }
      .background-options {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 10px;
        margin: 20px 0;
      }
      .bg-option {
        width: 50px;
        height: 50px;
        border-radius: 4px;
        cursor: pointer;
        border: 3px solid transparent;
      }
      .bg-option.selected {
        border: 3px solid #4caf50;
      }
      .bg-gradient-1 {
        background: linear-gradient(to right, #2193b0, #6dd5ed);
      }
      .bg-gradient-2 {
        background: linear-gradient(to right, #373b44, #4286f4);
      }
      .bg-gradient-3 {
        background: linear-gradient(to right, #8e2de2, #4a00e0);
      }
      .bg-solid-1 {
        background-color: #333333;
      }
      .bg-solid-2 {
        background-color: #f5f5f5;
      }
      .controls-section {
        background-color: white;
        padding: 15px;
        border-radius: 4px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }
      .controls-section h3 {
        margin-top: 0;
        color: #555;
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <h1>Professional Headshot Generator</h1>
      <p style="text-align: center">
        Create professional headshots directly in your browser. No data is sent
        to any server.
      </p>

      <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text">Loading TensorFlow models...</div>
      </div>

      <div class="controls-section">
        <h3>Camera Controls</h3>
        <div class="controls">
          <button id="startCamera">Start Camera</button>
          <button id="switchCamera" disabled>Switch Camera</button>
          <button id="captureImage" disabled>Capture Headshot</button>
          <button id="downloadImage" disabled>Download</button>
        </div>
      </div>

      <div class="controls-section">
        <h3>Background Style</h3>
        <div class="background-options">
          <div
            class="bg-option bg-gradient-1 selected"
            data-bg="gradient-1"
          ></div>
          <div class="bg-option bg-gradient-2" data-bg="gradient-2"></div>
          <div class="bg-option bg-gradient-3" data-bg="gradient-3"></div>
          <div class="bg-option bg-solid-1" data-bg="solid-1"></div>
          <div class="bg-option bg-solid-2" data-bg="solid-2"></div>
        </div>
      </div>

      <div class="canvas-container">
        <div class="canvas-wrapper">
          <h3>Camera Feed</h3>
          <video id="video" playsinline></video>
        </div>
        <div class="canvas-wrapper">
          <h3>Professional Headshot</h3>
          <canvas id="output"></canvas>
        </div>
      </div>

      <div id="status">Ready to start.</div>
    </div>

    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>

    <!-- Load BodyPix model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.2.0/dist/body-pix.min.js"></script>

    <script>
      // Global variables
      let video;
      let bodyPixModel;
      let streaming = false;
      let currentStream = null;
      let facingMode = "user"; // Start with front camera by default
      let selectedBackground = "gradient-1";
      let capturedImageData = null;

      // DOM elements
      const startCameraButton = document.getElementById("startCamera");
      const switchCameraButton = document.getElementById("switchCamera");
      const captureImageButton = document.getElementById("captureImage");
      const downloadButton = document.getElementById("downloadImage");
      const loadingElement = document.getElementById("loading");
      const statusElement = document.getElementById("status");
      const outputCanvas = document.getElementById("output");
      const backgroundOptions = document.querySelectorAll(".bg-option");

      // Initialize the application
      async function init() {
        try {
          video = document.getElementById("video");

          // Load BodyPix model
          updateStatus("Loading BodyPix model...");
          bodyPixModel = await bodyPix.load({
            architecture: "MobileNetV1",
            outputStride: 16,
            multiplier: 0.75,
            quantBytes: 2,
          });

          updateStatus("Models loaded. Click 'Start Camera' to begin.");
          loadingElement.classList.add("hidden");
          startCameraButton.disabled = false;

          // Set up event listeners
          startCameraButton.addEventListener("click", startCamera);
          switchCameraButton.addEventListener("click", switchCamera);
          captureImageButton.addEventListener("click", captureImage);
          downloadButton.addEventListener("click", downloadImage);

          // Background options
          backgroundOptions.forEach((option) => {
            option.addEventListener("click", function () {
              backgroundOptions.forEach((opt) =>
                opt.classList.remove("selected")
              );
              this.classList.add("selected");
              selectedBackground = this.dataset.bg;
              if (capturedImageData) {
                processImage(capturedImageData);
              }
            });
          });

          // Set up output canvas
          outputCanvas.width = 640;
          outputCanvas.height = 480;
        } catch (error) {
          console.error("Initialization error:", error);
          updateStatus("Error initializing app: " + error.message);
          loadingElement.classList.add("hidden");
        }
      }

      // Update status message
      function updateStatus(message) {
        statusElement.textContent = message;
        document.getElementById("loading-text").textContent = message;
      }

      // Start camera
      async function startCamera() {
        try {
          if (currentStream) {
            stopCamera();
          }

          updateStatus("Accessing camera...");
          const constraints = {
            video: {
              facingMode: facingMode,
              width: { ideal: 640 },
              height: { ideal: 480 },
            },
            audio: false,
          };

          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          currentStream = stream;
          video.srcObject = stream;

          video.onloadedmetadata = () => {
            video.play();
            streaming = true;
            switchCameraButton.disabled = false;
            captureImageButton.disabled = false;
            startCameraButton.textContent = "Stop Camera";
            updateStatus(
              "Camera is active. Position yourself and click 'Capture Headshot'."
            );
          };
        } catch (error) {
          console.error("Error accessing camera:", error);
          updateStatus("Error accessing camera: " + error.message);
        }
      }

      // Stop camera
      function stopCamera() {
        if (currentStream) {
          currentStream.getTracks().forEach((track) => track.stop());
          currentStream = null;
          video.srcObject = null;
          streaming = false;
          switchCameraButton.disabled = true;
          captureImageButton.disabled = true;
          startCameraButton.textContent = "Start Camera";
          updateStatus("Camera stopped.");
        }
      }

      // Switch between front and back cameras
      function switchCamera() {
        facingMode = facingMode === "user" ? "environment" : "user";
        startCamera();
      }

      // Capture image
      async function captureImage() {
        if (!streaming || !bodyPixModel) {
          updateStatus("Camera not active or model not loaded.");
          return;
        }

        try {
          updateStatus("Processing image...");

          // Segment person from background
          const segmentation = await bodyPixModel.segmentPerson(video, {
            flipHorizontal: false,
            internalResolution: "medium",
            segmentationThreshold: 0.7,
          });

          // Process image and show result
          processImage(segmentation);
          capturedImageData = segmentation;
          downloadButton.disabled = false;

          updateStatus("Headshot captured! You can download it or try again.");
        } catch (error) {
          console.error("Error capturing image:", error);
          updateStatus("Error processing image: " + error.message);
        }
      }

      // Process the captured image with person segmentation
      function processImage(segmentation) {
        const ctx = outputCanvas.getContext("2d");
        const width = video.videoWidth;
        const height = video.videoHeight;

        outputCanvas.width = width;
        outputCanvas.height = height;

        // Draw background based on selected style
        drawBackground(ctx, width, height, selectedBackground);

        // Create a temporary canvas to handle the person segmentation
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = width;
        tempCanvas.height = height;
        const tempCtx = tempCanvas.getContext("2d");

        // Draw the original video frame to the temporary canvas
        if (facingMode === "user") {
          // Mirror the image for selfie mode
          tempCtx.translate(width, 0);
          tempCtx.scale(-1, 1);
        }
        tempCtx.drawImage(video, 0, 0, width, height);

        // Get the image data from the temporary canvas
        const imageData = tempCtx.getImageData(0, 0, width, height);

        // Apply the segmentation mask
        const maskData = new ImageData(width, height);
        for (let i = 0; i < segmentation.data.length; i++) {
          // For each pixel, check if it's part of a person
          const j = i * 4;
          if (segmentation.data[i] === 1) {
            // This pixel is part of a person
            maskData.data[j] = imageData.data[j]; // R
            maskData.data[j + 1] = imageData.data[j + 1]; // G
            maskData.data[j + 2] = imageData.data[j + 2]; // B
            maskData.data[j + 3] = 255; // A (fully opaque)
          }
          // Otherwise, leave the pixel transparent (it's already 0)
        }

        // Put the masked person image on top of the background
        ctx.putImageData(maskData, 0, 0);

        // Apply some enhancement filters
        enhanceImage(ctx, width, height);
      }

      // Draw different background styles
      function drawBackground(ctx, width, height, style) {
        switch (style) {
          case "gradient-1":
            const gradient1 = ctx.createLinearGradient(0, 0, width, height);
            gradient1.addColorStop(0, "#2193b0");
            gradient1.addColorStop(1, "#6dd5ed");
            ctx.fillStyle = gradient1;
            break;
          case "gradient-2":
            const gradient2 = ctx.createLinearGradient(0, 0, width, height);
            gradient2.addColorStop(0, "#373B44");
            gradient2.addColorStop(1, "#4286f4");
            ctx.fillStyle = gradient2;
            break;
          case "gradient-3":
            const gradient3 = ctx.createLinearGradient(0, 0, width, height);
            gradient3.addColorStop(0, "#8e2de2");
            gradient3.addColorStop(1, "#4a00e0");
            ctx.fillStyle = gradient3;
            break;
          case "solid-1":
            ctx.fillStyle = "#333333";
            break;
          case "solid-2":
            ctx.fillStyle = "#f5f5f5";
            break;
          default:
            ctx.fillStyle = "#2193b0";
        }

        ctx.fillRect(0, 0, width, height);
      }

      // Apply image enhancements to make the headshot look more professional
      function enhanceImage(ctx, width, height) {
        // Get image data
        const imageData = ctx.getImageData(0, 0, width, height);
        const data = imageData.data;

        // Increase contrast and brightness slightly
        for (let i = 0; i < data.length; i += 4) {
          // Skip transparent pixels
          if (data[i + 3] === 0) continue;

          // Increase contrast slightly
          data[i] = data[i] * 1.05; // R
          data[i + 1] = data[i + 1] * 1.05; // G
          data[i + 2] = data[i + 2] * 1.05; // B

          // Subtle warming filter (add slight orange/yellow tint)
          data[i] = Math.min(255, data[i] + 5); // Add a bit more red
          data[i + 1] = Math.min(255, data[i + 1] + 3); // Add a bit more green

          // Make sure values stay within 0-255
          data[i] = Math.min(255, Math.max(0, data[i]));
          data[i + 1] = Math.min(255, Math.max(0, data[i + 1]));
          data[i + 2] = Math.min(255, Math.max(0, data[i + 2]));
        }

        // Put the enhanced image data back
        ctx.putImageData(imageData, 0, 0);

        // Apply a subtle vignette effect (darkened corners)
        const centerX = width / 2;
        const centerY = height / 2;
        const maxDistance = Math.sqrt(centerX * centerX + centerY * centerY);

        ctx.globalCompositeOperation = "multiply";
        const gradient = ctx.createRadialGradient(
          centerX,
          centerY,
          maxDistance * 0.6,
          centerX,
          centerY,
          maxDistance
        );
        gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
        gradient.addColorStop(1, "rgba(200, 200, 200, 1)");
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, width, height);

        // Reset composite operation
        ctx.globalCompositeOperation = "source-over";
      }

      // Download the headshot
      function downloadImage() {
        try {
          const dataURL = outputCanvas.toDataURL("image/png");
          const link = document.createElement("a");
          link.href = dataURL;
          link.download = "professional-headshot.png";
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          updateStatus("Image downloaded!");
        } catch (error) {
          console.error("Error downloading image:", error);
          updateStatus("Error downloading image: " + error.message);
        }
      }

      // Initialize the app when page loads
      window.addEventListener("load", init);
    </script>
  </body>
</html>
